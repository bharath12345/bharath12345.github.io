---
layout: post
title: "Why Learn Scala?"
category: posts
tags: []
categories: []
published: false
tweetfb: true
disqus: true
---
I don't remember the first time I read this masterpiece of an article by software guru, Peter Norvig - [Teach Yourself Programming In Ten Years](http://norvig.com/21-days.html#answers). Peter advises wannabe programmers to learn at least a dozen programming languages. In my decade long career, I have worked deeply in only 4 languages - C++, Java, JavaScript and Perl. So taking stock of myself, about 6 months ago, I had two questions in mind - 

* Why do I need another language? 
* If at all, then which one?

The answer to the first one was rather easy to find. I started by reading what was new in Java-7 and what was coming up in Java-8. Java-7 with its *invoke dynamic* and Java-8 built for writing *lambdas* were clearly pointing the finger in a certain direction. The JVM had started its embrace of Polyglotism and Functional Programming. On little more fact finding, the reasons were easy to realise. Java with its type-safety mess-up, lack of immutable data structures in the JDK to fight the menace of shared mutability and just sheer verbosity, were beginning to weigh heavy on the language. These factors, along with the more and more distributed multicore computing world with its new challenges, convinced me of the need to look to start anew.

Surprisingly, the second question turned out to be the tougher of the two to answer. The choice essentially is between Groovy, Scala and Clojure. I chose Scala. This article is a small attempt to articulate the reasons for the choice as I climb the rather steep learning curve. My pre-learning decision has got richly rewarded by what I have learnt after taking the plunge. This write-up is rather a little too theoretical. For *show-me-the-code* types, I will soon write about a not-so-small 3-tier application I have built entirely with Scala. 


Scala is a mix of best of 

1. Haskell - Type Inferencing, Type classes, Pattern Matching
2. Erlang - Actor
3. C# - Implicits
4. Java - The JVM

Exposure to new and revisit assumptions on -

1. Type safety
2. Immutable data structures
3. More concise code
4. 


#### Product Perspective
Its a interesting question - which programming language would you choose to write your next product? 

* If you are a startup web product company, you may choose NodeJS. If you have reliable Ruby expertise then Rails is still a great choice. By the way, no one ever got fired for picking Java. And if you have been slightly out of touch with things lately, then you may end up choosing the old war-horse PHP
* But if the product is for enterprise customers, designers and managers alike tend to favour Java heavily. And not without reasons. The Java ecosystem is stable and rich in libraries and design patterns. Lot of engineering expertise is widely available. And so on...

It is a wise choice of 'picking the right battles'.


