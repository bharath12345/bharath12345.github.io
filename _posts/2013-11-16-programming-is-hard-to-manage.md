---
layout: post
title: "Programming Is Hard To Manage"
category: posts
tags: []
categories: []
published: false
tweetfb: true
disqus: true
toc: true
---

A couple of recent incidents triggered me to write this article. Few weeks ago, I met an old friend. A fellow software industry man. But unlike me, a people manager. As we both shared our our small experiences in software development, my friend picked on my recently acquired MBA. Give me something I can use my friend demanded. I promised him this blog.

Now the second incident. A month ago I logged into my (almost) discarded yahoo-mail. Had created it in 2001 and used it actively till around 2006 (when Gmail happened). In my yahoo mailbox I found a folder with a few of my musings from my early years as a software engineer.  One was titled *Bewilderment*. It was a list of processes, decisions and people's actions that were totally counter-intuitive to me. At the end of the piece I had advised myself to study psychology to understand these things! I closed my eyes for a minute and tried to think if I continued to find software development bewildering. I was happy to note that I could answer some of my own questions and 
     
Over the years I have searched, read and re-read books which could broaden my understanding of the wonderful enterprise of software development. In this blog I shall be quoting from 7 such books. I would advise these books to anybody to whom Software development is dear. 

#### Understand At The Team, Project and Organization Level
1. **The Mythical Man Month** *by Dr. Fredrick Brooks Jr*
3. **Adrenaline Junkies and Template Zombies** *by Tom DeMarco, Tim Lister et al*
4. **The Inmates Are Running The Asylum** *by Alan Cooper* 

<img src="http://bharathwrites.in/images/programmingIsHard/team.jpg" alt="Drawing" style="width: 500px;"/>

#### Understand and Improve At The Individual level -
1. **Hackers and Painters** *by Paul Graham*
2. **Dreaming In Code** *by Scott Rosenberg*
3. **Beautiful Code** *articles by Brian Kerninghan, Charles Petzold, Douglas Crockford, Jeffrey Dean, Sanjay Ghemawat and many more super programmers*
4. **The Productive Programmer** *by Neal Ford*

<img src="http://bharathwrites.in/images/programmingIsHard/individual.jpg" alt="Drawing" style="width: 500px;"/>

<hr>

### The Mythical Man Month *- Dr. Fred Brooks*

This is a brilliant must-read book for any one aspiring a career in software. Fred Brooks charts the complete territory - from programming languages to organization to design. And provides superbly constructed scientific arguments and thesis for all propositions. Let me state some of his hypothesis (for there is no way to capture the essence of this massive work)... 
  
> I believe the critical need to be the preservation of the conceptual integrity of the product itself

> Joys of the craft of programming: Making things. Helping others. Solving complex problems. Learning. Working in such a tractable medium

> Woes: Perfection. Meet specifications. Inter-dependence. Bug fixing is painful. By the time one builds something usable on a technological base, the technologies are obsolete and the base has moved!

> Why do software projects go awry? Techniques of estimation are poor. Everyone in the trade confuses *effort* with *progress*. Software managers often lack stubbornness. Progress is poorly monitored. Too often managers try to counter schedule slippage by adding resources (people, hardware, software etc)

> The man-month as a unit for measuring the size of a job is a dangerous and deceptive myth. It implies that men and months are interchangeable. Men and months are interchangeable commodities only when a task can be partitioned among many workers with no communication among them
> Brooks Law: Adding manpower to a late software project makes it later.

> Software construction is inherently a systems effort (an exercise in complex interrelationships) communication and training effort is great, and it quickly dominates the decrease in individual task time brought about by partitioning. Adding more men then lengthens, not shortens, the schedule.

> The ratio of performance of individuals in software has often averaged about 10:1 in productivity tests. And this ratio is further widening with the advent of more sophisticated programming languages and frameworks. Thus, to identify high performing individuals and assign roles so that their productivity is maximised, whilst accommodating lesser accomplished for tasks that are more mundane is a major organisational challenge which managers do not pay enough heed to.

> Are not the architects a new aristocracy, an intellectual elite, set up to tell the poor dumb implementers what to do? The answer is partially both yes and no.  If a system is to have conceptual integrity, someone must control the concepts. That is an aristocracy that needs no apology. But 'No' because the implementation, given an architecture, requires and should allow as much creativity, as many new ideas
and technical brilliance as the external specifications. Indeed, the cost-performance ratio of the product will depend most heavily on the implementer, just as ease of use depends most heavily on the architect.

> The accusation that 'architects will get all the creative fun and shut out the inventiveness of the implementers' needs to be assuaged by constructive management that creative effort involves three distinct phases: architecture, implementation, and realization - none of which is lesser in intellectual challenge

> Large projects need all types of communication - Informal, Formal. Oral (meetings) and written

> Software entities are more complex for their size than perhaps any other human construct, because no two parts are alike. The physicist labors on, however, in a firm faith that there are unifying principles to be found, whether in quarks or in unified field theories. Einstein repeatedly argued that there must be simplified explanations of nature, because God is not capricious or arbitrary.No such faith comforts the software engineer. Much of the complexity he must master is arbitrary complexity, forced with- out rhyme or reason by the many human institutions and sys- tems to which his interfaces must conform. These differ from interface to interface, and from time to time, not because of ne- cessity but only because they were designed by different people, rather than by God.
> Most fundamentally, as I have argued above, software is very difficult to visualize